/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Weekly Contest 477
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: Q3756. Concatenate Non-Zero Digits and Multiply by Sum II
ğŸ“Œ Platform: LeetCode
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Prefix Sum, Binary Search, Math, Rolling Hash

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given a string `s` representing a large integer and multiple queries `[L, R]`:
1. Form integer `x` by concatenating non-zero digits of `s[L...R]`.
2. Calculate `sum` of these non-zero digits.
3. Return `(x * sum) % (10^9 + 7)`.

With $N, Q \le 10^5$, the challenge is to move from a linear scan per query to a logarithmic or constant time query.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âŒ Version 1: Brute Force (TLE)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

This approach iterates through the range for every single query. 
Complexity: O(Q * N) â€” This will exceed the time limit.
*/

class SolutionTLE {
    typedef long long ll;
    int mod = 1e9 + 7;
public:
    long long solved(string &s, int l, int r) {
        ll ans = 0;
        ll sum = 0;
        ll final = 1;
        for (int i = r; i >= l; i--) {
            int digit = s[i] - '0';
            if (digit != 0) {
                sum += digit;
                ans = (digit * final + ans) % mod;
                final = (final * 10) % mod;
            }
        }
        return (ans % mod) * (sum % mod) % mod;
    }
    
    vector<int> sumAndMultiply(string s, vector<vector<int>>& queries) {
        vector<int> ans;
        for (auto &q : queries) {
            ans.push_back(solved(s, q[0], q[1]));
        }
        return ans;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Version 2: Optimized (Binary Search + Prefix Sums)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Approach:
1. Filter out zeros: Store non-zero digits in `d` and their original indices in `p`.
2. Prefix Arrays: 
   - `ps`: Prefix sum of digits.
   - `pv`: Prefix value of the concatenated number (like a rolling hash).
   - `pw`: Precomputed powers of 10.
3. Query: Use `lower_bound` on `p` to find which non-zero digits fall in `[L, R]`.
4. Math: Use the prefix value formula to extract the range value in O(1).

Complexity: O(N + Q log N)
*/

class Solution {
public:
    vector<int> sumAndMultiply(string s, vector<vector<int>>& q) {
        const int M = 1000000007;
        int n = s.size();
        vector<int> p, d;
        
        // Extract non-zero digits and their positions
        for (int i = 0; i < n; i++) {
            if (s[i] != '0') {
                p.push_back(i);
                d.push_back(s[i] - '0');
            }
        } 

        int m = d.size(), k = q.size();
        vector<int> ps(m), pv(m), pw(m + 1, 1), ans(k);

        if (m) {
            ps[0] = pv[0] = d[0];
            for (int i = 1; i < m; i++) {
                ps[i] = ps[i - 1] + d[i];
                pv[i] = (int)(((long long)pv[i - 1] * 10 + d[i]) % M);
            }
            for (int i = 1; i <= m; i++) {
                pw[i] = (int)((long long)pw[i - 1] * 10 % M);
            }
        }

        for (int i = 0; i < k; i++) {
            int L = q[i][0], R = q[i][1];
            
            // Binary search to find the range of non-zero indices
            int a = lower_bound(p.begin(), p.end(), L) - p.begin();
            int b = upper_bound(p.begin(), p.end(), R) - p.begin() - 1;

            if (a > b) {
                ans[i] = 0;
                continue;
            }

            // Sum of digits in range [a, b]
            long long s2 = ps[b] - (a ? ps[a - 1] : 0);
            
            // Value x in range [a, b] using Rolling Hash subtraction logic
            long long v2;
            if (a == 0) v2 = pv[b];
            else v2 = (pv[b] - (long long)pv[a - 1] * pw[b - a + 1] % M + M) % M;

            ans[i] = (int)((v2 * (s2 % M)) % M);
        }
        return ans;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

* Time Complexity: O(N + Q log N)
  - Precomputation: O(N)
  - Query: Q queries * O(log N) for binary search.
* Space Complexity: O(N) to store the prefix arrays.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Notes
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

* The "Rolling Hash" logic `v2 = (pv[b] - pv[a-1] * 10^(len))` is the standard 
  way to get the value of a substring in O(1).
* Binary search is necessary because the input string `s` has zeros, making 
  the non-zero digit indices non-contiguous.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
