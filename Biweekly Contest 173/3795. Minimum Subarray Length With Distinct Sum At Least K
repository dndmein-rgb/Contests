/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Contest: LeetCode Biweekly Contest 173
ğŸ“… Date: January 4, 2026
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3795. Minimum Subarray Length With Distinct Sum At Least K
ğŸ“Œ Link: https://leetcode.com/problems/minimum-subarray-length-with-distinct-sum-at-least-k/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Array, Hash Table, Sliding Window

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- An integer array `nums` and an integer `k`.

Goal:
- Find the minimum length of a subarray such that the sum of its **distinct** elements is at least `k`.
- If no such subarray exists, return -1.

Key Insight:
- "Distinct sum" means if a number appears multiple times in a window, it is 
  only added once to the `curr_sum`.
- As we slide the window, the sum only changes when a number's frequency 
  transitions between 0 and 1.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach (Sliding Window / Two Pointers)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Window Management**: Use a `left` and `right` pointer to represent the window.
2. **Frequency Tracking**: Use an `unordered_map` (or frequency array) to keep 
   track of counts of elements in the current window.
3. **Sum Logic**:
   - When expanding (`right`++): If `counts[nums[right]] == 0`, add `nums[right]` 
     to `curr_sum`.
   - When shrinking (`left`++): If after decrementing, `counts[nums[left]] == 0`, 
     subtract `nums[left]` from `curr_sum`.
4. **Optimization**: While `curr_sum >= k`, update the `min_len` and shrink the 
   window from the left to find the smallest possible valid subarray.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/



class Solution {
public:
    int minLength(vector<int>& nums, int k) {
        int n = nums.size();
        int left = 0;
        long long curr_distinct_sum = 0;
        unordered_map<int, int> counts;
        int min_len = n + 1;

        for (int right = 0; right < n; right++) {
            // If it's the first time seeing this number in the current window
            if (counts[nums[right]] == 0) {
                curr_distinct_sum += nums[right];
            }
            counts[nums[right]]++;

            // Shrink window as long as the distinct sum condition is met
            while (curr_distinct_sum >= k) {
                min_len = min(min_len, right - left + 1);

                counts[nums[left]]--;
                // If the number is no longer in the window, remove from distinct sum
                if (counts[nums[left]] == 0) {
                    curr_distinct_sum -= nums[left];
                }
                left++;
            }
        }

        return (min_len == n + 1) ? -1 : min_len;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(N)
   â””â”€ Each element is visited by the right pointer once and the left pointer 
      at most once. Map operations are O(1) on average.
   
ğŸ’¾ Space Complexity: O(N)
   â””â”€ In the worst case, the unordered_map stores all unique elements of the array.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough (nums = [1, 2, 1, 3], k = 3)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Right=0, nums[0]=1: Sum=1, Map={1:1}
2. Right=1, nums[1]=2: Sum=3 (1+2), Map={1:1, 2:1}. Sum >= k!
   - min_len = 2.
   - Shrink Left=0: Sum=3-1=2, Map={1:0, 2:1}. Sum < k.
3. Right=2, nums[2]=1: Sum=2+1=3, Map={1:1, 2:1}. Sum >= k!
   - min_len = min(2, 2-1+1) = 2.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
