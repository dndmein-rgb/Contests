/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ—“ï¸ Contest: LeetCode Biweekly Contest 170
ðŸ“… Date: December 30, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸŽ¯ Problem: 3750. Minimum Number of Flips to Reverse Binary String
ðŸ“Œ Link: https://leetcode.com/problems/minimum-number-of-flips-to-reverse-binary-string/
ðŸ·ï¸ Difficulty: Medium
ðŸ† Topics: Bit Manipulation, String, Two Pointers

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- An integer n.

Goal:
- Convert n into its binary representation.
- Find the minimum number of bit flips (0 to 1 or 1 to 0) required so that the binary string becomes a palindrome (reads the same forwards and backwards).

Key Insight:
- A binary string is a palindrome if the bit at index i is equal to the bit at index (length - 1 - i).
- Each mismatch between s[i] and s[len - 1 - i] represents a position that must be changed to achieve symmetry.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Binary Conversion**:
   - Extract bits of n using `n & 1` and right-shifting `n >>= 1`.
   - Store these in a string `s`. This generates the binary representation in least-significant-bit (LSB) first order.

2. **Symmetry Verification**:
   - Iterate through the generated string.
   - Compare characters at mirrored positions from the start and end of the string.
   - If `s[i] != s[len - 1 - i]`, increment the flip count.



â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: n = 10 (Binary: 1010)

1. **String Construction**:
   - n = 10 (1010â‚‚) â†’ s = "0101" (LSB first)

2. **Mismatch Detection**:
   - i = 0: s[0] ('0') vs s[3] ('1') â†’ **Mismatch** (count = 1)
   - i = 1: s[1] ('1') vs s[2] ('0') â†’ **Mismatch** (count = 2)
   - i = 2: s[2] ('0') vs s[1] ('1') â†’ **Mismatch** (count = 3)
   - i = 3: s[3] ('1') vs s[0] ('0') â†’ **Mismatch** (count = 4)

Result: 4

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(log N)
   â””â”€ The number of bits in N is logâ‚‚(N). We traverse this length twice.
   
ðŸ’¾ Space Complexity: O(log N)
   â””â”€ Necessary to store the string representation of the binary digits.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int minimumFlips(int n) {
        if (n == 0) return 0;
        
        string s = "";
        // Step 1: Convert integer to binary string
        while (n > 0) {
            s.push_back((n & 1) + '0');
            n >>= 1;
        }
        
        int len = s.length();
        int count = 0;
        
        // Step 2: Count mismatches across the palindrome center
        for (int i = 0; i < len; i++) {
            if (s[i] != s[len - i - 1]) {
                count++;
            }
        }
        
        return count;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸŽ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ’¡ Why use string?
   - While we could use bitwise operations to check symmetry without a string, storing the bits makes handling the "length" of the binary representation much easier, especially since leading zeros (in terms of a fixed bit-width) are usually not considered unless specified.

âš ï¸ Implementation Note:
   - The current logic counts every mismatch. If the goal is to find the minimum flips to *make* it a palindrome, usually you only flip one side of the mismatch, meaning the result would be `count / 2`. However, following the user's specific logic provided, we count all positional differences.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
