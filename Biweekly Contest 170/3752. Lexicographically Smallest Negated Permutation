/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Contest: LeetCode Biweekly Contest 170
ğŸ“… Date: December 30, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3752. Lexicographically Smallest Negated Permutation
ğŸ“Œ Link: https://leetcode.com/problems/lexicographically-smallest-negated-permutation-that-sums-to-target/
ğŸ·ï¸ Difficulty: Medium/Hard
ğŸ† Topics: Greedy, Math, Permutations

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- An integer n (representing a permutation of 1 to n).
- A long long target sum.

Goal:
- Assign a sign (+ or -) to each number in the permutation {1, 2, ..., n}.
- The total sum must equal the target.
- The resulting sequence must be the lexicographically smallest possible.

Key Insight:
- Let the total sum of {1...n} be $S = \frac{n(n+1)}{2}$.
- If we change the sign of a number $x$ from positive to negative, the total sum decreases by $2x$.
- Therefore, $(S - \text{target})$ must be even and non-negative. 
- Let $diff = (S - \text{target}) / 2$. We need to pick a subset of numbers whose sum is exactly $diff$ and negate them.
- To make the sequence lexicographically smallest, we want the most negative numbers (like $-n, -(n-1)$) to appear as early as possible.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Feasibility Check**:
   - Max possible sum is $S$, min is $-S$. If $|target| > S$, return empty.
   - $(S - target)$ must be even because negating $x$ reduces the sum by an even amount ($2x$).

2. **Greedy Selection for Lexicographical Smallness**:
   - Smallest lexicographical order means putting the smallest possible numbers at the front.
   - Since $-n$ is the smallest possible value we can create, we check numbers from $n$ down to $1$. 
   - If a number $i$ can fit into our remaining $diff$, we mark it for negation.

3. **Constructing the Result**:
   - First, append all negated numbers from largest absolute value to smallest (e.g., $-n, -(n-1)...$).
   - Then, append all remaining positive numbers in increasing order ($1, 2, 3...$).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    vector<int> lexSmallestNegatedPerm(int n, long long target) {
        long long sum = 1LL * n * (n + 1) / 2;

        // Absolute bound check
        if (llabs(target) > sum) return {};

        // Difference must be even
        long long diff = sum - target;
        if (diff % 2 != 0) return {};

        diff /= 2;  // now we need subset sum = diff

        vector<bool> neg(n + 1, false);

        // Pick largest values first to get most negative lexicographically
        for (int i = n; i >= 1 && diff > 0; i--) {
            if (i <= diff) {
                neg[i] = true;
                diff -= i;
            }
        }

        // If we couldn't reach the exact diff, return empty
        if (diff != 0) return {};

        vector<int> ans;

        // Negatives first (largest absolute values appear first to be smallest)
        for (int i = n; i >= 1; i--) {
            if (neg[i]) ans.push_back(-i);
        }

        // Then positives in increasing order
        for (int i = 1; i <= n; i++) {
            if (!neg[i]) ans.push_back(i);
        }

        return ans;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(N)
   â””â”€ Single loop to pick negations and two loops to construct the result array.
   
ğŸ’¾ Space Complexity: O(N)
   â””â”€ Boolean vector `neg` takes O(N) space, and the result vector `ans` takes O(N).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough (n=4, target=0)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Sum $S = 10$. Target = 0.
2. $diff = (10 - 0) / 2 = 5$.
3. Greedy: 
   - Can we take 4? Yes. $diff = 5 - 4 = 1$. Mark neg[4] = true.
   - Can we take 3? No ($3 > 1$).
   - Can we take 2? No ($2 > 1$).
   - Can we take 1? Yes. $diff = 1 - 1 = 0$. Mark neg[1] = true.
4. Result: [-4, -1, 2, 3]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
