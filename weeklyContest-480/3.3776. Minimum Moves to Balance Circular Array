/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Problem: 3776. Minimum Moves to Balance Circular Array
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Œ Link: https://leetcode.com/problems/minimum-moves-to-balance-circular-array/
ğŸ·ï¸ Difficulty: Hard
ğŸ“… Contest: LeetCode Weekly Contest 480
â±ï¸ Time Taken: 35 minutes

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given a circular array where elements can be positive, negative, or zero:
- You can move 1 unit from one position to an adjacent position
- Each move costs the distance traveled
- Goal: Make all elements non-negative
- Return minimum total moves, or -1 if impossible

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Greedy + Circular Array Simulation

Key Insights:
1ï¸âƒ£ If total sum < 0 â†’ impossible (not enough positive values)
2ï¸âƒ£ If no negative values â†’ already balanced, return 0
3ï¸âƒ£ Find any negative position and fill it greedily from nearest neighbors

Algorithm:
1ï¸âƒ£ Check if sum of all elements â‰¥ 0 (feasibility check)
2ï¸âƒ£ Find any position with negative value (culprit)
3ï¸âƒ£ Expand outward in circular manner:
   â€¢ At distance d, check positions (culprit-d) and (culprit+d)
   â€¢ Take available positive values from both sides
   â€¢ Cost = distance Ã— units_moved
4ï¸âƒ£ Repeat until culprit position becomes non-negative

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input:  balance = [3, -2, 4, 1]

Step 1: Check sum = 3 + (-2) + 4 + 1 = 6 â‰¥ 0 âœ… (possible)

Step 2: Find culprit = index 1 (value = -2)

Step 3: Expand and fill:
  Distance 1:
    â€¢ Left:  index 0, value = 3
    â€¢ Right: index 2, value = 4
    â€¢ Total available = 3 + 4 = 7
    â€¢ Need = 2
    â€¢ Take 2 units (cost = 1 Ã— 2 = 2)
    â€¢ balance[1] becomes 0 âœ…
    
Total moves: 2

Output: 2

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(nÂ²)
   â””â”€ Worst case: need to check all distances (n iterations)
   â””â”€ Each iteration does O(1) work
   â””â”€ Total: O(n) for sum check + O(nÂ²) for filling
   
ğŸ’¾ Space Complexity: O(1)
   â””â”€ Only using constant extra variables
   â””â”€ Modifying input array in-place

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    typedef long long ll;
    
    long long minMoves(vector<int>& balance) {
        int n = balance.size();
        
        // ğŸ“Š Step 1: Check feasibility - is total sum non-negative?
        ll sum = 0;
        ll culprit = -1;  // Index of any negative value
        
        for(int i = 0; i < n; i++) {
            sum += balance[i];
            if(balance[i] < 0) {
                culprit = i;  // Remember any negative position
            }
        }
        
        // âŒ If sum < 0, impossible to balance
        if(sum < 0) return -1;
        
        // âœ… If no negative values found, already balanced
        if(culprit == -1) return 0;
        
        // ğŸ¯ Step 2: Greedily fill the negative position
        ll moves = 0;
        ll distance = 1;  // Start checking neighbors at distance 1
        
        while(balance[culprit] < 0) {
            // ğŸ”„ Calculate circular indices for left and right neighbors
            ll left = (culprit - distance + n) % n;
            ll right = (culprit + distance) % n;
            
            // ğŸ’° Calculate total available from both sides
            ll total = balance[left] + balance[right];
            
            // âš ï¸ Edge case: if left == right (distance wraps around)
            // Don't count the same position twice
            if(left == right) {
                total -= balance[left];
            }
            
            // ğŸ“¦ Calculate how much we need and can take
            ll need = -balance[culprit];  // How much deficit to fill
            ll taken = min(need, total);  // Take minimum of need and available
            
            // ğŸ’¸ Add cost: distance Ã— units moved
            moves += distance * taken;
            
            // ğŸ”§ Update the culprit position
            balance[culprit] += taken;
            
            // ğŸ“ Move to next distance level
            distance++;
        }
        
        return moves;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Pattern: Greedy + Circular Array + Two-Pointer Expansion
ğŸ”‘ Trick: Use modulo arithmetic for circular indexing: (i + n) % n
âš ï¸ Edge Case: When left == right (same position due to wraparound)
ğŸ¯ Optimization: Only need to fix one negative position (greedy works)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Why This Works
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

The greedy approach works because:
1. If sum â‰¥ 0, there's always enough positive value to distribute
2. Taking from nearest neighbors minimizes cost (distance Ã— units)
3. Fixing one negative position doesn't create new problems elsewhere
4. Circular property ensures we can always reach all positions

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”§ Alternative Approaches
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Fix ALL negative positions simultaneously (more complex)
2. Use prefix sum approach (similar complexity)
3. Binary search on answer (overkill for this problem)

Current greedy approach is optimal for this problem! âœ…

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
