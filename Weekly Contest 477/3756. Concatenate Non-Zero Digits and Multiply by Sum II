/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Contest: LeetCode Weekly Contest 477
ğŸ“… Date: December 21, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3756. Concatenate Non-Zero Digits and Multiply by Sum II
ğŸ“Œ Link: https://leetcode.com/problems/concatenate-non-zero-digits-and-multiply-by-sum-ii/
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Prefix Sum, Rolling Hash, Math, String

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given a string `s` of digits and several range queries `[l, r]`:
1. Extract all non-zero digits in the range.
2. Concatenate them to form a number $num$.
3. Find the sum of those non-zero digits $digitSum$.
4. Return $(num \times digitSum) \pmod{10^9 + 7}$.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Solution 1: Brute Force (O(Q * N))
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Suitable for small constraints. We iterate through the range for every query.
*/

class SolutionBruteForce {
public:
    vector<int> sumAndMultiply(string s, vector<vector<int>>& q) {
        const int mod = 1000000007;
        int n = q.size();
        vector<int> ans(n);

        for (int qi = 0; qi < n; qi++) {
            int l = q[qi][0], r = q[qi][1];
            long long num = 0, digitSum = 0;
            
            for (int i = l; i <= r; i++) {
                int d = s[i] - '0';
                if (d != 0) {
                    num = (num * 10 + d) % mod;
                    digitSum += d;
                }
            }
            ans[qi] = (num * (digitSum % mod)) % mod;
        }
        return ans;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Solution 2: Optimized Prefix Hash (O(N + Q))
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Required for large constraints ($N, Q \le 10^5$). 

We use the Rolling Hash logic:
To get the number in range [L, R], we take the prefix value at R and subtract 
the prefix value at L-1, shifted left by the number of digits in the range.

Formula: $Value(L, R) = (PrefNum[R] - PrefNum[L-1] \times 10^{count\_nonzero(L,R)}) \pmod M$
*/



class Solution {
public:
    vector<int> sumAndMultiply(string s, vector<vector<int>>& q) {
        const int mod = 1000000007;
        int n = s.length();
        
        // Prefix arrays for O(1) range queries
        vector<long long> prefSum(n + 1, 0);   // Sum of non-zero digits
        vector<long long> prefNum(n + 1, 0);   // Value of concatenated non-zero digits
        vector<int> nzCount(n + 1, 0);         // Count of non-zero digits
        vector<long long> pow10(n + 1, 1);     // Powers of 10 mod 10^9 + 7

        // Precomputation - O(N)
        for (int i = 0; i < n; i++) {
            pow10[i + 1] = (pow10[i] * 10) % mod;
            int d = s[i] - '0';
            
            prefSum[i + 1] = prefSum[i];
            prefNum[i + 1] = prefNum[i];
            nzCount[i + 1] = nzCount[i];

            if (d != 0) {
                prefSum[i + 1] = (prefSum[i] + d) % mod;
                prefNum[i + 1] = (prefNum[i] * 10 + d) % mod;
                nzCount[i + 1]++;
            }
        }

        // Query processing - O(Q)
        vector<int> ans;
        for (auto& query : q) {
            int l = query[0], r = query[1];
            
            // 1. Calculate Digit Sum in O(1)
            long long dSum = (prefSum[r + 1] - prefSum[l] + mod) % mod;
            
            // 2. Calculate Concatenated Number in O(1)
            int totalNzInRange = nzCount[r + 1] - nzCount[l];
            long long num = (prefNum[r + 1] - (prefNum[l] * pow10[totalNzInRange] % mod) + mod) % mod;
            
            ans.push_back((num * dSum) % mod);
        }
        return ans;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis (Optimized)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(N + Q)
   â””â”€ Precomputation takes O(N). Each of the Q queries is answered in O(1).
   
ğŸ’¾ Space Complexity: O(N)
   â””â”€ We maintain 4 prefix arrays of size N to enable fast lookups.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
