/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Contest: LeetCode Weekly Contest 481
ğŸ“… Date: December 22, 2024
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3783. Mirror Distance of an Integer
ğŸ“Œ Link: https://leetcode.com/problems/mirror-distance-of-an-integer/
ğŸ·ï¸ Difficulty: Easy
ğŸ† Topics: Math, String Manipulation

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given a positive integer n:
- Find its mirror (reverse of digits)
- Return the absolute difference between n and its mirror

Mirror = Reverse of the digits
Distance = |n - mirror|

Examples:
- n = 123 â†’ mirror = 321 â†’ distance = |123 - 321| = 198
- n = 505 â†’ mirror = 505 â†’ distance = |505 - 505| = 0
- n = 100 â†’ mirror = 001 = 1 â†’ distance = |100 - 1| = 99

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Digit-by-Digit Reversal

Algorithm:
1ï¸âƒ£ Extract digits from n one by one (from right to left)
2ï¸âƒ£ Build reversed number by:
   - Multiply current reversed number by 10
   - Add the extracted digit
3ï¸âƒ£ Return absolute difference between n and reversed number

Visual Process for n = 123:
  Initial: x = 123, rev = 0
  
  Step 1: digit = 3
    rev = 0 * 10 + 3 = 3
    x = 12
  
  Step 2: digit = 2
    rev = 3 * 10 + 2 = 32
    x = 1
  
  Step 3: digit = 1
    rev = 32 * 10 + 1 = 321
    x = 0
  
  Result: |123 - 321| = 198

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 1: n = 123

Step-by-step reversal:
  x = 123, rev = 0
  
  Iteration 1:
    digit = 123 % 10 = 3
    rev = 0 * 10 + 3 = 3
    x = 123 / 10 = 12
  
  Iteration 2:
    digit = 12 % 10 = 2
    rev = 3 * 10 + 2 = 32
    x = 12 / 10 = 1
  
  Iteration 3:
    digit = 1 % 10 = 1
    rev = 32 * 10 + 1 = 321
    x = 1 / 10 = 0
  
  Exit loop (x = 0)
  
  Distance = |321 - 123| = 198

Example 2: n = 505 (Palindrome)

Step-by-step:
  x = 505, rev = 0
  
  Iteration 1: digit = 5, rev = 5, x = 50
  Iteration 2: digit = 0, rev = 50, x = 5
  Iteration 3: digit = 5, rev = 505, x = 0
  
  Distance = |505 - 505| = 0

Example 3: n = 100 (Trailing zeros)

Step-by-step:
  x = 100, rev = 0
  
  Iteration 1: digit = 0, rev = 0, x = 10
  Iteration 2: digit = 0, rev = 0, x = 1
  Iteration 3: digit = 1, rev = 1, x = 0
  
  Distance = |100 - 1| = 99
  (Leading zeros in reversed number are dropped!)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(log n)
   â””â”€ Number of digits in n = logâ‚â‚€(n)
   â””â”€ We process each digit once
   
ğŸ’¾ Space Complexity: O(1)
   â””â”€ Only using constant extra space (x, rev, digit variables)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int mirrorDistance(int n) {
        int x = n;      // Working copy of n
        int rev = 0;    // Reversed number
        
        // ğŸ”„ Reverse the digits of n
        while (x > 0) {
            // ğŸ“Š Extract rightmost digit
            int digit = x % 10;
            
            // ğŸ”¢ Build reversed number:
            // Shift existing digits left (Ã—10) and add new digit
            rev = rev * 10 + digit;
            
            // â¡ï¸ Remove rightmost digit from x
            x /= 10;
        }
        
        // ğŸ¯ Return absolute difference
        return abs(rev - n);
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Technique: Digit Extraction and Reconstruction
   - Use modulo (%) to extract rightmost digit
   - Use integer division (/) to remove rightmost digit
   - Build new number by multiplying by 10 and adding digit

ğŸ”‘ Why This Works:
   - Numbers are processed right-to-left in extraction
   - Reversed number is built left-to-right
   - Perfect for creating mirror image!

âš ï¸ Edge Cases:
   - Palindromes (e.g., 121) â†’ distance = 0
   - Numbers with trailing zeros (e.g., 100) â†’ leading zeros dropped
   - Single digit (e.g., 5) â†’ distance = 0
   - All same digits (e.g., 333) â†’ distance = 0

ğŸ¯ Mathematical Pattern:
   For number with digits dâ‚dâ‚‚dâ‚ƒ...dâ‚™
   - Original: dâ‚Ã—10^(n-1) + dâ‚‚Ã—10^(n-2) + ... + dâ‚™Ã—10^0
   - Reversed: dâ‚™Ã—10^(n-1) + dâ‚™â‚‹â‚Ã—10^(n-2) + ... + dâ‚Ã—10^0

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Detailed Trace: Building Reversed Number
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

For n = 1234:

Initial State:
  x = 1234
  rev = 0

â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ Step â”‚ Digit  â”‚ Calculation     â”‚ rev      â”‚ x    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0    â”‚ -      â”‚ Initial         â”‚ 0        â”‚ 1234 â”‚
â”‚ 1    â”‚ 4      â”‚ 0*10 + 4        â”‚ 4        â”‚ 123  â”‚
â”‚ 2    â”‚ 3      â”‚ 4*10 + 3        â”‚ 43       â”‚ 12   â”‚
â”‚ 3    â”‚ 2      â”‚ 43*10 + 2       â”‚ 432      â”‚ 1    â”‚
â”‚ 4    â”‚ 1      â”‚ 432*10 + 1      â”‚ 4321     â”‚ 0    â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜

Result: |1234 - 4321| = 3087

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Alternative Approaches
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Approach 1: String Manipulation (Current approach is better)
  string s = to_string(n);
  reverse(s.begin(), s.end());
  int rev = stoi(s);
  return abs(n - rev);

âœ… Current (Math): O(log n) time, O(1) space
âŒ String: O(log n) time, O(log n) space

Approach 2: Recursive
  int reverse(int x, int rev = 0) {
      if (x == 0) return rev;
      return reverse(x / 10, rev * 10 + x % 10);
  }

âœ… Current: Iterative, no stack overhead
âŒ Recursive: Extra stack space O(log n)

Current approach is optimal! ğŸ¯

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Special Cases
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Case 1: Palindrome Numbers
  n = 12321
  reversed = 12321
  distance = 0 âœ…

Case 2: Trailing Zeros
  n = 1000
  reversed = 0001 = 1  (leading zeros dropped!)
  distance = 999 âœ…

Case 3: Single Digit
  n = 7
  reversed = 7
  distance = 0 âœ…

Case 4: Two Digits
  n = 42
  reversed = 24
  distance = 18 âœ…

Case 5: All Same Digits
  n = 7777
  reversed = 7777
  distance = 0 âœ…

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Pattern: Digit Manipulation Template
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

This is a fundamental pattern for digit manipulation:

// Extract digits from right to left
while (x > 0) {
    int digit = x % 10;    // Get rightmost digit
    // Process digit here
    x /= 10;               // Remove rightmost digit
}

Common uses:
- Reverse number (this problem)
- Sum of digits
- Count digits
- Check palindrome
- Digital root
- Convert number to different base

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Reverse Integer (LeetCode 7)
- Palindrome Number (LeetCode 9)
- Add Digits (LeetCode 258)
- Happy Number (LeetCode 202)
- Sum of Digits in Base K
- Perfect Number

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Learning Points
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ… Modulo (%) extracts rightmost digit
2. âœ… Integer division (/) removes rightmost digit
3. âœ… Multiply by 10 shifts digits left
4. âœ… Leading zeros are automatically dropped in integers
5. âœ… abs() handles both positive and negative differences

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
