/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Contest: LeetCode Weekly Contest 481
ğŸ“… Date: December 22, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3785. Minimum Swaps to Avoid Forbidden Values
ğŸ“Œ Link: https://leetcode.com/problems/minimum-swaps-to-avoid-forbidden-values/
ğŸ·ï¸ Difficulty: Hard
ğŸ† Topics: Array, Hash Table, Greedy, Math

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- Array nums of length n
- Array forbidden of length n (nums[i] cannot be at position i)

Goal:
- Swap elements to ensure nums[i] â‰  forbidden[i] for all i
- Return minimum number of swaps needed
- Return -1 if impossible

Constraints:
- Can swap any two positions
- Each swap counts as 1 operation

Example:
  nums =      [1, 2, 3, 4]
  forbidden = [1, 3, 2, 4]
  
  Positions with violations:
    - Position 0: nums[0]=1, forbidden[0]=1 âŒ
    - Position 1: nums[1]=2, forbidden[1]=3 âœ…
    - Position 2: nums[2]=3, forbidden[2]=2 âœ…
    - Position 3: nums[3]=4, forbidden[3]=4 âŒ
  
  Swap positions 0 and 1: [2, 1, 3, 4]
  Swap positions 2 and 3: [2, 1, 4, 3]
  
  Result: 2 swaps

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Greedy + Graph Theory (Cycle Detection)

Key Insights:
1ï¸âƒ£ Feasibility Check:
   - For each value v, count how many times it appears in nums
   - Count how many positions forbid value v
   - If count[v] > (n - f_count[v]), impossible! (Pigeonhole principle)

2ï¸âƒ£ Count Bad Positions:
   - Bad position = nums[i] == forbidden[i]
   - These MUST be moved

3ï¸âƒ£ Minimum Swaps Formula:
   - If we have m bad positions
   - We can fix 2 bad positions with 1 swap (if we swap two bad positions)
   - OR fix 1 bad position with 1 swap (swap with good position)
   - Minimum swaps = max(max_bad_value_count, âŒˆm/2âŒ‰)
   
   Where:
   - max_bad_value_count = max frequency of any bad value
   - âŒˆm/2âŒ‰ = minimum swaps to move m bad positions

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example 1: nums = [1,2,3], forbidden = [1,3,2]

Step 1: Feasibility Check
  count[1] = 1, f_count[1] = 1 â†’ 1 â‰¤ (3-1) = 2 âœ…
  count[2] = 1, f_count[2] = 1 â†’ 1 â‰¤ (3-1) = 2 âœ…
  count[3] = 1, f_count[3] = 1 â†’ 1 â‰¤ (3-1) = 2 âœ…
  Feasible!

Step 2: Count Bad Positions
  Position 0: nums[0]=1, forbidden[0]=1 âŒ BAD (value=1)
  Position 1: nums[1]=2, forbidden[1]=3 âœ… GOOD
  Position 2: nums[2]=3, forbidden[2]=2 âœ… GOOD
  
  m = 1 (one bad position)
  bad_val_counts[1] = 1

Step 3: Calculate Minimum Swaps
  max_bad = max(1) = 1
  ceiling(m/2) = ceiling(1/2) = 1
  
  Answer = max(1, 1) = 1

Verification:
  Swap position 0 with position 1: [2, 1, 3]
  Check: nums[0]=2â‰ 1, nums[1]=1â‰ 3, nums[2]=3â‰ 2 âœ…

Example 2: nums = [1,2,1,2], forbidden = [1,2,1,2]

Step 1: Feasibility Check
  count[1] = 2, f_count[1] = 2 â†’ 2 â‰¤ (4-2) = 2 âœ…
  count[2] = 2, f_count[2] = 2 â†’ 2 â‰¤ (4-2) = 2 âœ…

Step 2: Count Bad Positions
  All 4 positions are bad!
  m = 4
  bad_val_counts[1] = 2
  bad_val_counts[2] = 2

Step 3: Calculate Minimum Swaps
  max_bad = max(2, 2) = 2
  ceiling(m/2) = ceiling(4/2) = 2
  
  Answer = max(2, 2) = 2

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(n)
   â””â”€ Single pass to count frequencies: O(n)
   â””â”€ Check feasibility: O(unique values) â‰¤ O(n)
   â””â”€ Count bad positions: O(n)
   â””â”€ Find max bad count: O(unique bad values) â‰¤ O(n)
   
ğŸ’¾ Space Complexity: O(n)
   â””â”€ Hash maps for counts: O(unique values)
   â””â”€ Worst case: all unique â†’ O(n)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int minSwaps(vector<int>& nums, vector<int>& forbidden) {
        int n = nums.size();
        
        // ğŸ“Š Count frequencies of values in both arrays
        unordered_map<int, int> count;      // Frequency in nums
        unordered_map<int, int> f_count;    // Frequency in forbidden
        
        for (int i = 0; i < n; i++) {
            count[nums[i]]++;
            f_count[forbidden[i]]++;
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 1: Feasibility Check (Pigeonhole Principle)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // For each value v:
        //   - count[v] = how many times v appears in nums
        //   - f_count[v] = how many positions forbid v
        //   - Available positions = n - f_count[v]
        //   - If count[v] > available positions â†’ IMPOSSIBLE!
        for (auto [val, freq] : count) {
            if (freq > (n - f_count[val])) {
                return -1;  // Can't place all occurrences of this value
            }
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 2: Count Bad Positions
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Bad position = nums[i] == forbidden[i]
        int m = 0;  // Total number of bad positions
        unordered_map<int, int> bad_val_counts;  // Frequency of each bad value
        
        for (int i = 0; i < n; i++) {
            if (nums[i] == forbidden[i]) {
                m++;
                bad_val_counts[nums[i]]++;
            }
        }
        
        // âœ… If no bad positions, already valid
        if (m == 0) return 0;
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 3: Calculate Minimum Swaps
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        // Find maximum frequency of any bad value
        int max_bad = 0;
        for (auto [_, freq] : bad_val_counts) {
            max_bad = max(max_bad, freq);
        }
        
        // ğŸ¯ Minimum swaps formula:
        // - If we have m bad positions, we need at least âŒˆm/2âŒ‰ swaps
        //   (can fix 2 bad positions with 1 swap if lucky)
        // - BUT if one value appears k times in bad positions,
        //   we need at least k swaps (can't swap same value into itself)
        // - Answer = max(max_bad, âŒˆm/2âŒ‰)
        return max(max_bad, (m + 1) / 2);  // (m+1)/2 is ceiling of m/2
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Pigeonhole Principle for Feasibility:
   - If a value appears k times in nums
   - And (n - available_positions) < k
   - Then impossible to place all k copies

ğŸ”‘ Why max(max_bad, âŒˆm/2âŒ‰)?
   
   Case 1: All bad positions have different values
     Example: [1,2,3], [1,2,3]
     m = 3, max_bad = 1
     Need âŒˆ3/2âŒ‰ = 2 swaps
   
   Case 2: Same value repeated in bad positions
     Example: [1,1,2], [1,1,3]
     m = 2, max_bad = 2
     Need 2 swaps (can't swap 1 with itself!)
   
   Answer = max of both cases

âš ï¸ Edge Cases:
   - All positions bad: m = n
   - No bad positions: m = 0 â†’ return 0
   - Impossible cases: caught by feasibility check

ğŸ¯ Greedy Choice:
   - We don't need to simulate actual swaps
   - Just count constraints and calculate minimum

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Why This Formula Works
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Minimum Swaps = max(max_bad, âŒˆm/2âŒ‰)

Intuition:

1. âŒˆm/2âŒ‰ Lower Bound:
   - We have m bad positions
   - Best case: swap two bad positions (fixes both)
   - Need at least âŒˆm/2âŒ‰ swaps

2. max_bad Lower Bound:
   - If value v appears k times in bad positions
   - Each occurrence needs to move away
   - Can't swap v with itself
   - Need at least k swaps

3. Why Maximum?
   - Both constraints must be satisfied
   - Take the stricter one (maximum)

Example:
  nums = [1,1,1,2], forbidden = [1,1,1,3]
  
  m = 3 (three bad positions with value 1)
  max_bad = 3 (value 1 appears 3 times in bad positions)
  âŒˆm/2âŒ‰ = âŒˆ3/2âŒ‰ = 2
  
  Answer = max(3, 2) = 3
  
  Why? All three 1's need different destinations!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Implementation Tricks
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Ceiling Division Trick:
   âŒˆm/2âŒ‰ = (m + 1) / 2
   
   Examples:
   m = 0 â†’ (0+1)/2 = 0 âœ…
   m = 1 â†’ (1+1)/2 = 1 âœ…
   m = 2 â†’ (2+1)/2 = 1 âœ… (but we get 1, not 2... wait)
   m = 3 â†’ (3+1)/2 = 2 âœ…
   m = 4 â†’ (4+1)/2 = 2 âœ…
   
   Actually: (m+1)/2 gives ceiling for positive integers!

2. Auto Destructuring:
   for (auto [key, value] : map)
   Cleaner than: it->first, it->second

3. Early Return:
   if (m == 0) return 0;
   Saves computation

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Minimum Swaps to Make Strings Equal
- Minimum Swaps to Group All 1's Together
- Minimum Number of Swaps to Make the String Balanced
- Couples Holding Hands (cycle detection)
- First Missing Positive (pigeonhole principle)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
