/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Weekly Contest 478: 3759. Count Elements With at Least K Greater Values
ğŸ“… Date: January 6, 2026
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3759. Count Elements With at Least K Greater Values
ğŸ“Œ Link: https://leetcode.com/problems/count-elements-with-at-least-k-greater-values/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Array, Sorting, Binary Search

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- An integer array `nums` of length `n`.
- An integer `k`.

Goal:
- Count how many elements have **at least k** elements in the array that are **strictly greater** than them.

Key Insight:
- If we sort the array in ascending order, the elements to the right of any index `i` are greater than or equal to `nums[i]`.
- For `nums[i]` to have at least `k` strictly greater elements, there must be an element at a position at least `k` steps from the end of the array that is still strictly greater than `nums[i]`.
- Specifically, the element at index `n - k` is the "border" element. If `nums[i] < nums[n - k]`, then `nums[n - k]` and everything to its right (totaling `k` elements) are strictly greater than `nums[i]`.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach (Sorting + Target Boundary)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Sort the Array**: Sorting helps us quickly identify which elements are "larger" without nested loops.
2. **Identify the Pivot**: The $k$-th element from the end is located at `nums[n - k]`. 
3. **Strict Comparison**: 
   - Every element to the right of `n - k` is $\ge$ `nums[n - k]`. 
   - Therefore, if `nums[i] < nums[n - k]`, there are at least $k$ elements (from index $n-k$ to $n-1$) that are strictly greater than `nums[i]`.
4. **Count and Return**: Iterate from the start and count all elements that satisfy `nums[i] < nums[n - k]`.



â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    int countElements(vector<int>& nums, int k) {
        int n = nums.size();
        
        // Edge Case: If k is 0, every element has at least 0 elements greater than it.
        if (k == 0) return n;
        
        // If k is equal to or greater than n, no element can have k strictly greater elements.
        if (k >= n) return 0;

        // 1. Sort the array to bring larger elements to the end
        sort(nums.begin(), nums.end());
        
        // 2. The element at index (n - k) is our threshold.
        // If an element is strictly smaller than nums[n - k], then 
        // nums[n - k], nums[n - k + 1] ... nums[n - 1] are all strictly greater than it.
        // This set contains exactly k elements.
        int targetValue = nums[n - k];
        int count = 0;

        // 3. Count elements strictly less than the target value
        for (int i = 0; i < n; i++) {
            if (nums[i] < targetValue) {
                count++;
            } else {
                // Since the array is sorted, no further elements will satisfy the condition.
                break;
            }
        }

        return count;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(N log N)
   â””â”€ Dominated by the sorting of the array. The linear scan is O(N).
   
ğŸ’¾ Space Complexity: O(1) or O(log N)
   â””â”€ Depends on the sorting implementation (in-place vs. recursion stack).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough (nums = [3, 1, 5, 5, 2], k = 2)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Sort: [1, 2, 3, 5, 5]
2. n = 5, k = 2. Index n - k = 3.
3. targetValue = nums[3] = 5.
4. Compare:
   - 1 < 5? Yes (Count = 1)
   - 2 < 5? Yes (Count = 2)
   - 3 < 5? Yes (Count = 3)
   - 5 < 5? No.
5. Result: 3. (Elements 1, 2, and 3 all have at least two '5's strictly greater).
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
