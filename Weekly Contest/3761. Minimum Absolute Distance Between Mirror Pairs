/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Weekly Contest 478: 3761. Minimum Absolute Distance Between Mirror Pairs
ğŸ“… Date: January 6, 2026
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3761. Minimum Absolute Distance Between Mirror Pairs
ğŸ“Œ Link: https://leetcode.com/problems/minimum-absolute-distance-between-mirror-pairs/
ğŸ·ï¸ Difficulty: Medium/Hard
ğŸ† Topics: Hash Table, Math, String Manipulation

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given:
- An integer array `nums`.
- A "Mirror Pair" is defined as two indices $(i, j)$ such that $nums[i]$ is the reverse of $nums[j]$.

Goal:
- Find the minimum absolute distance $|i - j|$ among all possible mirror pairs.
- Return -1 if no such pair exists.

Key Insight:
- If we are at index $i$ with value $x$, we are looking for a previous index $j$ where $nums[j] = reverse(x)$.
- Instead of searching backward every time ($O(N^2)$), we can use a Hash Map to store the last seen position of a number's reverse.
- By storing `mp[reverse(x)] = i`, when we encounter `x` later at index `k`, we can instantly calculate the distance.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach (One-Pass Hash Map)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. **Reverse Function**: Create a helper `rev(num)` to flip the digits (e.g., 123 -> 321).
2. **Hash Map Strategy**: 
   - Use `unordered_map<int, int> mp` to store `{Value -> Last Seen Index}`.
   - As we iterate through `nums` at index `i`:
     - Check if the current value `nums[i]` exists in the map.
     - If it exists, it means we previously saw its "mirror" (because we store the reverse). Update `minDist`.
     - **Crucially**: Store the reverse of the current number: `mp[rev(nums[i])] = i`.
3. **Edge Case**: If the distance remains our initial large value, return -1.



â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    // Helper function to reverse the digits of an integer
    int rev(int num) {
        int x = 0;
        while (num > 0) {
            int digit = num % 10;
            x = x * 10 + digit;
            num /= 10;
        }
        return x;
    }

    int minMirrorPairDistance(vector<int>& nums) {
        // mp stores: [Required Mirror Value] -> [Latest Index where its counterpart was seen]
        unordered_map<int, int> mp;
        int n = nums.size();
        int minDistance = 1e9;

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            
            // 1. Check if the current value 'x' matches a reverse we are looking for
            if (mp.count(x)) {
                minDistance = min(minDistance, i - mp[x]);
            }
            
            // 2. Store the reverse of 'x' so that a future index 'j' 
            // looking for 'rev(x)' can find this index 'i'.
            int r = rev(x);
            mp[r] = i; 
        }

        return (minDistance == 1e9) ? -1 : minDistance;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity: O(N * log10(maxVal))
   â””â”€ We iterate through the array once (O(N)). For each number, we reverse 
      its digits (log10 of the value). Hash map operations are average O(1).
   
ğŸ’¾ Space Complexity: O(N)
   â””â”€ In the worst case, we store the reverse of every element in the hash map.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough (nums = [12, 45, 21, 54])
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. i=0, x=12: mp.count(12) is false. Store mp[rev(12)] -> mp[21] = 0.
2. i=1, x=45: mp.count(45) is false. Store mp[rev(45)] -> mp[54] = 1.
3. i=2, x=21: mp.count(21) is TRUE! dist = 2 - mp[21] = 2. minDistance = 2.
   Store mp[rev(21)] -> mp[12] = 2.
4. i=3, x=54: mp.count(54) is TRUE! dist = 3 - mp[54] = 2. minDistance = 2.
Result: 2.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
