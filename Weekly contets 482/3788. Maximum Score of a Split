/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—“ï¸ Contest: LeetCode Weekly Contest 482
ğŸ“… Date: December 29, 2024
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ Problem: 3788. Maximum Score of a Split
ğŸ“Œ Link: https://leetcode.com/problems/maximum-score-of-a-split/
ğŸ·ï¸ Difficulty: Medium
ğŸ† Topics: Array, Prefix Sum, Greedy

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– Problem Summary
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Given an array nums:
- Split array into two non-empty parts: left and right
- Score = (sum of left) - (minimum element in right)
- Return maximum possible score

Constraints:
- Must split: at least 1 element on each side
- Split at position i: left = [0...i], right = [i+1...n-1]

Example:
  nums = [1, 4, 3, 7, 4, 5]
  
  Split at index 3 (after 7):
    left = [1, 4, 3, 7]  â†’ sum = 15
    right = [4, 5]       â†’ min = 4
    score = 15 - 4 = 11

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Approach
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Strategy: Prefix Sum + Suffix Minimum

Key Insights:
1ï¸âƒ£ For each split position, we need:
   - Sum of left part (use prefix sum)
   - Minimum of right part (use suffix minimum)

2ï¸âƒ£ Precompute both:
   - P[i] = sum of nums[0...i]
   - S[i] = minimum of nums[i...n-1]

3ï¸âƒ£ Try all valid split positions:
   - Split at i means: left=[0...i], right=[i+1...n-1]
   - Score = P[i] - S[i+1]

4ï¸âƒ£ Return maximum score across all splits

Algorithm:
1ï¸âƒ£ Build prefix sum array P
2ï¸âƒ£ Build suffix minimum array S
3ï¸âƒ£ For each i in [0, n-2], calculate score = P[i] - S[i+1]
4ï¸âƒ£ Return maximum score

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” Example Walkthrough
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Input: nums = [1, 4, 3, 7, 4, 5]

Step 1: Build Prefix Sum Array P
  Index:  0  1  2   3   4   5
  nums:   1  4  3   7   4   5
  P:      1  5  8  15  19  24
          â†‘  â†‘  â†‘   â†‘   â†‘   â†‘
         1  1+4 5+3 8+7 15+4 19+5

Step 2: Build Suffix Minimum Array S
  Index:  0  1  2  3  4  5
  nums:   1  4  3  7  4  5
  S:      1  3  3  4  4  5
          â†‘  â†‘  â†‘  â†‘  â†‘  â†‘
      min(1,4,3,7,4,5)=1
         min(4,3,7,4,5)=3
            min(3,7,4,5)=3
               min(7,4,5)=4
                  min(4,5)=4
                     min(5)=5

Step 3: Try All Split Positions

Split at i=0: left=[1], right=[4,3,7,4,5]
  Score = P[0] - S[1] = 1 - 3 = -2

Split at i=1: left=[1,4], right=[3,7,4,5]
  Score = P[1] - S[2] = 5 - 3 = 2

Split at i=2: left=[1,4,3], right=[7,4,5]
  Score = P[2] - S[3] = 8 - 4 = 4

Split at i=3: left=[1,4,3,7], right=[4,5]
  Score = P[3] - S[4] = 15 - 4 = 11 âœ… MAX!

Split at i=4: left=[1,4,3,7,4], right=[5]
  Score = P[4] - S[5] = 19 - 5 = 14

Step 4: Return Maximum
  Answer: 11

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Complexity Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° Time Complexity:  O(n)
   â””â”€ Build prefix sum: O(n)
   â””â”€ Build suffix minimum: O(n)
   â””â”€ Try all splits: O(n)
   â””â”€ Total: O(n)
   
ğŸ’¾ Space Complexity: O(n)
   â””â”€ P array: O(n)
   â””â”€ S array: O(n)
   â””â”€ Total: O(n)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

class Solution {
public:
    long long maximumScore(vector<int>& nums) {
        int n = nums.size();
        
        // ğŸ“Š Arrays for preprocessing
        vector<long long> P(n);  // Prefix sum
        vector<long long> S(n);  // Suffix minimum
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 1: Build Prefix Sum Array
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P[i] = sum of nums[0...i]
        long long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            P[i] = sum;
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 2: Build Suffix Minimum Array
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // S[i] = minimum of nums[i...n-1]
        S[n - 1] = nums[n - 1];  // Last element
        
        for (int i = n - 2; i >= 0; i--) {
            // Current element vs minimum of rest
            S[i] = min((long long)nums[i], S[i + 1]);
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Step 3: Try All Valid Split Positions
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        long long maxScore = LLONG_MIN;
        
        // Split at i means: left=[0...i], right=[i+1...n-1]
        // Valid splits: i âˆˆ [0, n-2] (both parts non-empty)
        for (int i = 0; i < n - 1; i++) {
            // Score = (sum of left) - (min of right)
            long long score = P[i] - S[i + 1];
            maxScore = max(maxScore, score);
        }
        
        return maxScore;
    }
};

/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Key Insights
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Core Pattern: Prefix/Suffix Preprocessing
   - Precompute values needed for all splits
   - Avoid recomputation â†’ O(nÂ²) to O(n)

ğŸ”‘ Why Suffix Minimum?
   - Right part's minimum changes as split point moves
   - Suffix minimum allows O(1) query for any split
   - Building suffix array: O(n) once

âš ï¸ Edge Cases:
   - All positive numbers
   - All negative numbers
   - Monotonic increasing/decreasing
   - Single minimum in middle

ğŸ¯ Optimization Strategy:
   Score = sum(left) - min(right)
   
   To maximize:
   - Want large sum(left)
   - Want small min(right)
   
   Trade-off between both!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Visual Representation
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

For nums = [1, 4, 3, 7, 4, 5]:

Prefix Sum (P):
  Index:  0   1   2    3    4    5
  Value:  1   5   8   15   19   24
          â†‘   â†‘   â†‘    â†‘    â†‘    â†‘
         1  1+4 5+3 8+7 15+4 19+5

Suffix Minimum (S):
  Index:  0   1   2   3   4   5
  Value:  1   3   3   4   4   5
          â†‘   â†‘   â†‘   â†‘   â†‘   â†‘
    min from here to end â†’

All Splits:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  i  â”‚ Left   â”‚ Right   â”‚ Score â”‚ Formula â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0  â”‚ [1]    â”‚[4,3,7,4,5]â”‚ -2  â”‚ 1 - 3   â”‚
â”‚  1  â”‚ [1,4]  â”‚[3,7,4,5]â”‚  2    â”‚ 5 - 3   â”‚
â”‚  2  â”‚[1,4,3] â”‚[7,4,5]  â”‚  4    â”‚ 8 - 4   â”‚
â”‚  3  â”‚[1,4,3,7]â”‚[4,5]   â”‚ 11 âœ… â”‚ 15 - 4  â”‚
â”‚  4  â”‚[1,4,3,7,4]â”‚[5]   â”‚ 14    â”‚ 19 - 5  â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Maximum: 11 at split position 3

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Why This Solution is Optimal
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Naive Approach (O(nÂ²)):
  for i in range(n-1):
      leftSum = sum(nums[0:i+1])      // O(n)
      rightMin = min(nums[i+1:n])     // O(n)
      score = leftSum - rightMin
  
  Total: O(nÂ²) âŒ

Optimized Approach (O(n)):
  Precompute prefix sums â†’ O(n)
  Precompute suffix mins â†’ O(n)
  Query each split     â†’ O(1) per split Ã— n splits = O(n)
  
  Total: O(n) âœ…

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸš€ Space Optimization (if needed)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Can reduce to O(1) space by computing on-the-fly:

long long maximumScore(vector<int>& nums) {
    int n = nums.size();
    long long maxScore = LLONG_MIN;
    long long leftSum = 0;
    
    // First pass: calculate right minimums while building left sum
    vector<long long> rightMin(n);
    rightMin[n-1] = nums[n-1];
    for (int i = n-2; i >= 0; i--) {
        rightMin[i] = min((long long)nums[i], rightMin[i+1]);
    }
    
    // Second pass: try all splits
    for (int i = 0; i < n-1; i++) {
        leftSum += nums[i];
        maxScore = max(maxScore, leftSum - rightMin[i+1]);
    }
    
    return maxScore;
}

This uses O(n) space (rightMin only).
Can't reduce further as we need future info!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ Related Problems
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Similar patterns:
- Maximum Subarray (Kadane's with prefix sum thinking)
- Best Time to Buy and Sell Stock (prefix/suffix pattern)
- Trapping Rain Water (prefix max, suffix max)
- Product of Array Except Self (prefix/suffix products)
- Range Sum Query (prefix sum applications)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Learning Points
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. âœ… Prefix sum for cumulative queries
2. âœ… Suffix minimum for range minimum
3. âœ… Preprocessing to optimize queries
4. âœ… Splitting problems into left/right parts
5. âœ… Trade-off optimization (sum vs min)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/
